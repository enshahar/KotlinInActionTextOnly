# 1장. 강력하고 실용적인 코틀린

이번 장은 현대적인 애플리케이션을 개발할 때 코틀린이 훌륭하며 효율적인 언어인 이유와 여러분이 코틀린을 배워야 하는 이유를 설명한다. 코틀린 설계를 뒷받침하는 기본적인 사상과 여러 응용 영역에 어떤 코틀린 라이브러리와 프레임워크가 있는지 전반적으로 살펴본다. 특히 안드로이드 애플리케이션, 동시성, 테스트, 웹 개발 분야를 살펴본다. 결론에서는 두가지 유명한 개발 환경인 인텔리J(IntelliJ) IDEA와 이클립스(Eclipse)에서 코틀린 프로젝트를 설정하는 방법을 한단계씩 알려주고, 대화형 코틀린 셀에 대해 소개한다.

## 구조
- 코틀린은 무엇인가?
- 코틀린 생태계를 이루는 주요 구성요소
- 인텔리J와 이클립스에서 코틀린 프로젝트 설정하기

## 목표

이 장을 끝낸 독자는 코틀린의 기본적인 원리와 코틀린 생태계에 대해 이해하고, 간단한 코틀린 프로그램의 생김새를 알게 되며, 자주 쓰이는 IDE에서 코틀린 프로젝트를 설정하는 방법을 알게된다.

## 코틀린이란 무엇인가?

코틀린은 안전성, 간결성, 상호운용성을 강조하는 다중 패러다임 프로그래밍 언어다. 2010년 하반기 처음 생겨났고, 2016년 2월 처음 공개 릴리스됐으며, 안드로이드 개발, 데스크탑 애플리케이션, 서버측 솔루션 등 여러 개발 분야에서 유망한 도구로 계속 유명해지고 있다. 코틀린 언어를 뒷받침하고 코틀린 언어 개발에 계속 투자해온 회사는 젯브레인즈(JetBrains)인데, 젠브레인즈는 인텔리J IDEA 등의 여러 훌륭한 소프트웨어 엔지니어링 도구로 유명하다.

2019년 11월 코틀린 1.3이 나왔고, 2021년 5월 1.5.0이 나왔다. 코틀린 커뮤니티도 아주 커졌고, 잘 개발된 생태계와 광범위한 도구들이 만들어졌다. 자바에 대해 더 나은 대안을 제공하려는 원래 언어를 만든 목적을 넘어서서 코틀린이 자라나면서, 이제 코틀린은 자바 가상 기계, 안드로이드, 자바스크립트, 네이티브 애플리케이션 등의 여러 플랫폼을 지원한다. 2017년 구글(Google)은 안드로이드 플랫폼의 공식 지원 언어로 코틀린을 선택했다. 이로 인해 코틀린 언어 사용자가 엄청나게 늘어났다. 현재 구글, 아마존(Amazon), 넷플릭스(Netflix), 핀터레스트(Pinterest), 우버(Uber) 등의 여러 회사가 프로덕션 개발에 코틀린을 사용하고, 코틀린 개발자를 채용하려는 회사도 계속 늘어나고 있다.

이 모든 일은 언어를 주의깊게 설계하고 언어의 주요 특성에 그 설계를 녹여넣기 위해 헌신적인 노력 때문에 가능했다. 이런 노력으로 인해 코틀린은 아주 훌륭한 개발자 도구가 됐다. 언어 철학은 주로 2010년 코틀린이 마주했던 문제에 기인한다. 그 시점에 젯브레인즈에는 인텔리J 플랫폼, 특히 가장 잘 알려졌음에 분명한 인텔리J IDEA나 웹스톰(WebStorm), Php스톰, 루비마인(RubyMine) 등을 중심으로 하는 자바 코드 기반이 누적되어 있었다. 

하지만 코드 기반의 성장과 유지보수는 자바 언어 자체로 인해, 특히 자바의 발전이 느렸고 2010년 당시 시점에 스칼라나 C# 등의 언어에서 사용할 수 있었던 유용한 기능이 자바에 없었기 때문에, 방해받기 시작했다. 당시 사용가능한 JVM 언어를 검토한 결과 젯브레인즈는 자신의 필요를 충족할만한 언어가 없다는 결론을 내렸고, 그에 따라 자원을 투입하 지신만의 언어를 개발하기로 결정했다. 새로운 언어에는 개발 팀원 상당수가 위치했던 러시아 상트페테르부르크 근처의 섬인 코틀린이라는 이름이 붙었다.

그렇다면, 처음에 코틀린 언어를 만들어간 특징은 무엇일까? 사실은 코틀린 언어 정의에서 이 특징에 대해 이미 이야기했다. 코틀린 개발을 뒷받침하는 이유는 안전성, 간결성, 상호운용성을 강조하는 다중 패러다임 언어가 필요하다는 것이었다. 각각의 특징을 더 자세히 살펴보자.

## 안전성

프로그래밍 언어가 안전하려면 프로그래머의 오류를 방지할 수 있어야 한다. 실전에서는 오류를 방지하려면 대가가 필요하기 때문에 안전성을 고려해 언어를 설계하는 것은 트레이드오프(tradeoff)의 문제다. 컴파일러에게 프로그램에 대한 정보를 더 자세히 알려주거나, 컴파일러가 더 오랬동안 프로그램이 올바른지 추론하게 할 수 있다(또는 두가지 다 할수도 있다). 코틀린의 설계 목표는 황금비를 찾아내는 것이었다. 자바보다 더 안전성을 보장하는 언어를 설계하되, 자바보다는 개발자의 생산성을 덜 헤치는 언어를 만드는 것이었다. 코틀린의 해법은 어떤 측면에서든 절대적인 것이 아니었다. 단지 실질적으로 효율적인 선택임이 반복적으로 증명됐다.

이 책을 진행하면서 코틀린의 안전성을 여러가지 측면에서 설명할 것이다. 여기서는 몇가지 중요한 특징을 짚고 넘어가고 싶다.

- 타입 추론(type inference)으로 인해 개발자가 명시적으로 타입을 지정하지 않아도 된다(자바10에도 지역 변수에 대한 타입 추론이 도입됐다).
- 널이 될 수 있는 타입(nullable type)을 통해 `null`의 사용을 제한할 수 있고, 악명높은 `NullPointerException` 예외를 좀 더 쉽게 방지할 수 있다.
- 스마트캐스트(smart cast)를 통해 타입을 안전하게 변환할 수 있고, 실행 시점에 타입 캐스트 오류를 방지할 수 있다.

### 다중 패러다임

초기에 코틀린이 다중 패러다임이라는 말의 의미는 자바와 같은 전형적인 주요 프로그래밍 언어가 지원하는 일반적인 객체지향 패러다임 외에 함수형 프로그래밍을 지원한다는 뜻이었다. 함수형 프로그래밍은 함수를 다른 값과 마찬가지로 다룬다는 생각에서 비롯된 프로그래밍 방법이다. 그래서 함수를 다른 함수의 인수로 넘기거나, 지역적으로 함수를 선언하거나, 변수에 저장하거나, 함수가 함수를 반환하는 등의 일이 가능하다. 함수형 프로그래밍의 다른 측면으로는 불변성(immutability)이라는 면이 있다. 이는 여러분이 만든 객체는 내부 상태를 바꿀 수 없고, 함수는 부수 효과(side effect)를 만들어낼 수 없다는 말이다.

이런 접근 방법의 큰 이점은 유연성이다. 새로운 유형의 추상화를 만들어낼 수 있어서 훨씬 더 표현력이 좋고 간결한 코드를 작성할 수 있으며, 이에 따라 생산성이 좋아진다.

> 함수형 프로그래밍 원칙이 여러 언어에 도입됐음에도 불구하고(예를 들어 자바의 익명 클래스는 분명 람다(lambda)를 도입하기 위한 좋은 바탕이 될 수 있다), 이런 언어들이 모두 다 함수형 코드를 작성하기 편리한 문법적인 도구를 제공하지는 않는다.

반면, 코틀린은 처음부터 필요한 도구를 제공했다. 특히 코틀린은 처음부터 함수 타입을 부드럽게 조화시킨 타입 시스템(type system)과 함수 타입의 값을 코드 블럭으로부터 만들어낼 수 있는 람다를 제공했다. 표준 라이브러리나 외부 프레임워크들도 함수형 프로그래밍 스타일을 장려하는 방대한 API를 제공한다. 자바도 자바 8부터는 함수형 프로그래밍에 대한 지원을 시작했기 때문에, 요즘은 이런 요소 중 상당수가 자바에도 도입됐다. 하지만 자바의 표현력은 코틀린의 표현력에 비해 상당히 떨어진다.

함수형 프로그래밍의 기초에 대해서는 5장에서 다룬다. 하지만 이 책 여러 부분에서 함수형 프로그래밍 예제를 볼 수 있다.

코틀린 언어가 성장해 나가면서, 두가지 프로그래밍 패러다임을 더 지원하기 시작했다. API를 *도메인 특화 언어(domain specific language)*로 정의할 수 있는 기능으로 인해, 코틀린을 선언적인 스타일로 코딩할 수도 있다. 사실 여러 코틀린 프레임워크들은 범용 프로그래밍 언어게 제공하는 타입 안전성이나 표현력을 해하지 않으면서 DSL을 제공한다. 예를 들어 exposed 프레임워크는 데이터베이스 스키마(schema)를 정의하고 데이터베이스에 저장된 데이터를 조작할 수 있는 DSL을 포함하며, kotlinx.html은 타입 안전성을 보장하는 새로운 HTML 템플릿 언어를 제시한다. *11장. 도메인 특화 언어*에서 이런 예제를 더 자세히 살펴보고, 직접 DSL을 만드는 방법도 살펴본다.

한가지 패러다임은 이름 그대로 동시성(concurrent) 프로그래밍이다. 코루틴을 도입하면서 코틀린도 동시성 프로그래밍을 지원하기 시작했다. 자바를 포함한 여러 언어가 동시성을 지원하지만, 코틀린은 새로운 프로그래밍 접근 방법을 가능하게 해주는 풍부한 프로그래밍 패턴을 제공한다. 동시성에 대한 기본적인 내용을 *13장. 동시성*에서 다룬다.

이 모두를 한꺼번에 제공하기 때문에 다중 패러다임은 언어의 표현력을 아주 많이 늘려주며, 언어를 더 유연하고 더 다용도에 사용할 수 있는 도구로 만들어준다.

## 간결성과 표현력

개발자 생산성은, 코드가 다른 사람이 짠 것이든 본인 스스로가 짠 것을 한참 후에 보는 것이든 관계 없이, 주로 빠르게 읽고 이해할 수 있는 코드를 작성할 수 있는지와 연관되어 있다. 어떤 코드 조각의 의미를 이해하기 위해서는 그 조각이 프로그램의 다른 부분과 어떤 관계가 있는지를 빠르게 이해할 필요가 있다. 그래서 기존 코드의 의미를 파악하는게 새로 코드를 작성하는 것보다 일반적으로 더 오랜 시간이 걸리고, 언어의 간결성, 즉 프로그래머의 의도를 잡음 정보 없이 명확하게 표현할 수 있는 능력이 개발 도구인 프로그래밍 언어에 있어 중요한 측면이다.

코틀린 설계자들은 필드 게터(getter)나 세터(setter), 익명 클래스, 명시적인 위임 등 자바의 악명높은 불필요한 준비 코드를 제고하고 언어를 가능한 간결하게 만들기 위해 노력했다. 반면 코틀린 설계자들은 간결성을 너무 과용하지 못하게 하기 위해 주의를 기울였다. 예를 들어 스칼라와 달리 코틀린에서는 커스텀 연산자를 정의할 수 없고, 기존의 연산자만 재정의할 수 있다. 이는 새 연산자로 인해 연산의 의미가 오히려 더 혼란스러워지기 때문이다. 이 책에서는 이런 결정으로 인한 결과와 결과적으로 이 결정이 얼마나 유용한지에 대해 많은 예를 볼 수 있다.

코틀린의 간결성의 다른 측면은 DSL과 밀접히 연관된다(*11장. 도메인 특화 언어*를 보라). DSL은 문법적인 잡음을 최소화하면서 특정 프로그래밍 범위에 대한 기술을 아주 간결하게 만들어준다.

## 상호운용성

코틀린은 독립적으로 존재하는 언어가 아니며, 가능한 기존의 (자바) 코드 기반과 부드럽게 협력해야만 했기 때문에, 자바 상호운용성은 코틀린 설계시 중요한 목적이었다. 그래서 코틀린 설계자들은 기존 자바 코드를 코틀린에서 사용할 수 있게 했을 뿐 아니라, 코틀린 코드를 거의 아무 노력도 없이 자바에서 사용할 수 있도록 보장하기 위해 노력했다. 코틀린 언어에는 자바와 코틀린의 상호 운용성을 조절하기 위한 특별한 기능도 몇가지 포함한다.

코틀린이 JVM을 벗어나 커지고, 다른 플랫폼으로 퍼져 나감에 따라, 상호운용성 보장은 자바스크립트, 즉 JS 플랫폼이나 네이티브 애플리케이션인 C/C++/오브젝티브(Objective) C/스위프트(Swift) 코드와의 상호작용까지 포함하는 범위로 확장되어 왔다.

*12장. 자바 상호 운용성*에서 자바 상호 운용성에 대해 다루고, 코틀린과 자바를 한 프로젝트 안에서 함께 사용하는 방법에 대해 설명한다.

## 다중 플랫폼

코틀린 설계자들의 원래 의도에는 다중 플랫폼이 없었다. 하지만 코틀린 언어가 진화하고 채택됨에 따라 개발자 커뮤니티에 의해 다중 플랫폼 지원 필요성이 제기됐다. 여전히 JVM과 안드로이드가 코틀린 개발의 주 대상이지만, 코틀린은 요즘 다름과 같은 플랫폼도 지워한다.

- 브라우저나 노드(Node.js) 애플리케이션이나 자바스크립트 라이브러리까지 포함하는 자바스크립트 지원
- macOS나 리눅스(Linux), 윈도우(Window) 라이브러리나 애플리케이션을 포함하는 네이티브 지원

코틀린 1.3버전부터 다중플랫폼 개발을 지원하며, 주된 용례로는 안드로이드와 iOS 애플리케이션 사이에 코드 기반을 공유하거나, JVM/JS/네이티브 세계에서 사용할 다중플랫폼 라이브러리를 만드는 것 등이 포함된다.

## 코틀린 생태계

그동안 진화해 오면서 코틀린에는 소프트웨어 개발의 거의 모든 측면에 대한 풍부한 라이브러리와 프레임워크가 만들어졌다. 여기서는 여러분에게 사용가능한 도구를 전반적으로 성명하고, 이런 가능성의 바다를 여러분이 헤처나가기 위한 안내를 제공하려 한다. 하지만 에코시스템이 끊임없이 자라고 있기 때문에, 이 책에서 최신이라고 소개한 내용들이 시간이 지남에 따라 낡은 프로젝트가 될 수 있다. 따라서 여러분이 주저하지 말고 직접 관련 내용을 찾아보기 바란다. 커뮤니티가 계속 갱신하고 있는 사용가능 라이브러리와 프레임워크 목록인 놀라운 코틀린(Awesome Kotlin) 웹사이트(https://kotlin.link)가 좋은 출발점이다.

그리고 코틀린이 제공하는 좋은 자바 상호운용성 덕분에 기존 자바 라이브러리가 주는 이익을 활용할 수도 있다는 점을 업급할만한 가치가 있다. 경우에 따라서는 자바 라이브러리를 좀 더 코틀린답게 사용할 수 있는 코틀린 확장이 있을 수도 있다.

## 코루틴

일시중단 가능한 계산(suspendable computation)이라는 개념으로 인해 코틀린은 async/await, 퓨처(future), 프라미스(promise), 액터(actor) 등의 동시성 관련 프로그래밍 패턴을 지원할 수 있다. 코루틴 프레임워크는 서버쪽이거나 모바일, 또는 데스탑을 위한 것인지와 관계 없이 코틀린 애플리케이션에서 동시성 문제를 해결할 수 있는 강력하고 우아하며 쉽게 확장가능한 해법을 제공한다. 코루틴에 포함된 주요 기능은 다음과 같다.

- 스레드에 대한 더 가벼운(lightweight) 대안
- 유연한 스레드 디스패치(dispatch) 메커니즘
- 일시중단 가능한 시퀀스와 이터레이터(iterator)
- 채널(channel)을 사용한 메모리 공유
- 액터를 통해 메시지 전송방식으로 상태를 공유

코루틴 API와 코틀린에서 동시성을 다르는 방법의 기초를 *13장. 동시성*에서 다룬다. 

## 테스트

[편집자께: 아마 저자들이 서문을 쓸 때는 모키토/스펙을 중심으로 하려고 했던것 같은데, 실제 14장 내용은 모두 코테스트만 사용합니다. 약간 본문을 바꿨습니다. 코틀린테스트는 이름을 코테스트로 바꿨습니다.]

테스트를 정의하거나 객체를 모킹(mocking) 하고 싶을 때, JUnit, TestNG, 모키토(Mockito)와 같은 익숙한 자바 테스트 프레임워크 중 일부를 거의 아무런 노력도 기울이지 않고 코틀린에 적용할 수 있고, 개발자는 코틀린에 맞춰 개발된 테스트를 위한 유용한 DSL을 제공하는 프레임워크의 강력함을 즐길 수도 있다. 특히 다음을 언급하고 싶다.

- 모키토-코틀린(Mockito-Kotlin)은 유명한 모키토 프레임워크를 확장한 것으로 코틀린 객체 모킹을 단순화해준다.
- 스펙(Spek)은 행위 주도(behavior-driven) 테스트 프레임워크로, 자스민(Jasmine)이나 저킨(Gherkin) 스타일의 테스트케이스 정의를 지원한다.
- 코테스트(Kotest)는 스칼라테스트(ScalaTest)에 의해 영감을 얻은 프레임워크로, 유연한 테스트 정의와 단언문(assertion)을 지원한다.

*14장. 코틀린 테스팅*에서는 이중에서도 코테스트가 지원하는 기능을 더 자세히 살펴보고, 여러분의 프로젝트에서 이들을 사용하는 방법에 대해 생각해본다.

## 안드로이드 개발

안드로이드는 코틀린의 응용 분야중 가장 중심적이고 활발하게 성장하는 분야이다. 특히 구글이 코틀린을 1급 안드로이드 언어로 선언하면서  안드로이드 개발에서 코틀린이 중요해졌다. 안드로이드 도구들은 이제 코틀린의 특징을 염두에 두고 설계와 개발이 이뤄지고 있다. 안드로이드 스튜디오 플러그인이 제공하는 훌륭한 프로그래밍 경험과 더불어, 안드로이드 개발자들은 대거(Dagger), 버터나이프(ButterKnife), DB플로우(DBFlow)등의 여러 유명한 프레임워크와의 부드러운 상호운용성의 이점을 살릴 수 있다. 코틀린에 특화된 안드로이드 개발 도구 중에서 안코(Anko)와 코틀린 안드로이드 확장(Kotlin Android Extension)에 관심을 기울이고 싶다.

코틀린 안드로이드 확장은 데이터바인딩이 주요 특징인 컴파일러 플러그인이다. 이를 사용하면 XML로 정의한 뷰를 코드 안에서 정의한 것처럼 사용할 수 있기 때문에 악명높은 `findViewById()` 호출을 피할 수 있다. 그 외에도 뷰 캐싱을 지원하고, 사용자가 정의한 클래스에 대한 `Parcelable` 구현을 자동으로 생성할 수 있다. 이로 인해 순수 코틀린 프로젝트에서 `ButterKnife`와 같은 외부 프레임워크를 채용할 필요가 없어졌다.

안코는 코틀린 라이브러리로, 안드로이드 앱 개발을 단순화시켜준다. 여러가지 도움이 되는 기능 중에는 안드로이드 SQLite에 대한 데이터베이스 질의(query) DSL과 안드로이드 스튜디오에서 사용할 수 있는 UI 미리보기 플러그인이 제공되는 동적 레이아웃 합성 영역 특화 언어(안코 레이아웃즈(Anko Layouts)가 있다. 

이 중 일부를 *15장. 안드로이드 애플리케이션*에서 다룬다. 또, 15장에서는 코틀린을 활용한 안드로이드 개발에 대해 독자들에게 소개한다.

## 웹 개발

웹/엔터프라이즈 애플리케이션 개발자들도 코틀린의 이점을 살릴 수 있다. 스프링 5.0이나 Vert.x 3.0과 같은 유명한 프레임워크들은 자신의 기능을 좀 더 코틀린다운 방식으로 활용할 수 있게 해주는 코틀린용 확장을 제공한다. 그 외에도 다양한 프레임워크를 사용하는 순수 코틀린 해법을 채용할 수도 있다.

- Ktor는 젯브레인즈에서 만든 비동기 서버와 클라이언트 애플리케이션 작성을 위한 프레임워크이다.
- `kotlinx.html`은 HTML 문서를 만들기 위한 DSL이다.
- 코데인(Kodein)은 의존관계 주입 프레임워크이다.

[편집자께: 16장에서는 ktor만 다루고 스프링은 17장에서 다룹니다. 문장을 좀 손봤습니다.]

Ktor를 활용한 웹 애플리케이션과 스프링 부트를 활용한 마이크로서비스 개발의 세부 사항에 대해 16장과 17장에서 다룬다.

## 코틀린 시작하기

이제 코틀린 생태계에 대해 알았으므로, 코틀린 언어에 대해 탐구하기 전에 여러분이 알아둬야 할 유일한 내용은 작업 환경을 어떻게 설정하느냐이다.

### 인텔리J 프로젝트 설정하기

대부분의 프로그래밍 언어와 마찬가지로 코틀란 자체는 어떤 특정 IDE나 텍스트 편집기에 메여있지는 않다. 하지만 어떤 개발자 도구를 선택하느냐가 개발자의 생산성에 미치는 영향은 아주 크다. 현재로써는 젯브레인즈의 인텔리J 플랫폼이 코틀린 개발 생명 주기를 가장 강력하고 종합적으로 지원해준다. 처음부터 코틀린 IDE는 언어 자체와 밀접한 연관을 가지고 개발되어 왔으며, 이로 인해 최신 코틀린 변경 사항을 가장 잘 반영한다. 이런 이유로 여러분도 인텔리J IDEA를 사용하라고 권장하며, 이 책의 예제에서도 이를 사용할 것이다.

인텔리J IDEA 15부터 코틀린 지원이 IDE 배포판에 기본 포함되어 있으므로, 코트린 개발을 시작하기 위해 다른 플러그인을 다운로드할 필요가 없다. 이 책에서는 2021년 4월 말에 배포된 인텔리J IDEA 2021.1.1을 기본으로 설명한다.

IDEA를 설치하지 않았다면 최종 버전을 www.jetbrains.com/idea/download 에서 다운로드해서 https://www.jetbrains.com/help/idea/installation-guide.html 에 있는 설치 절차를 따라 설치하라. IDEA는 두가지 에디션이 있다. 커뮤니티(Community) 에디션은 무료 오픈소스 버전이며, 얼티밋(Ultimate)은 상업적으로 판매되는 버전이다. 둘의 차이는 얼티밋이 웹과 엔터프라이즈 개발에 관계된 기능 뿐 아니라 데이터베이스 관련 기능까지 제공한다는 점에 있다. 좀 더 자세한 차이는 다운로드 페이지에서 확인할 수 있다. 이 책에서는 얼티밋이 제공하는 기능이 필요없으므로 IDEA 커뮤니티 버전으로도 충분하고도 남는다.

프로젝트를 인텔리J에서 열어본 적이 없다면 시작시 환영 창에서 "Create New Project" 옵션을 볼 수 있다. 이 옵션을 선택하면 바로 프로젝트 마법사를 시작한다. 그렇지 않다면 인텔리J는 최근에 사용했던 프로젝트(들)을 보여준다. 이런 경우 `File | New | Projet...`를 애플리케이션 메뉴에서 선택하라.

프로젝트 유형은 분류별로 창 왼쪽 사각 영역에 표시된다. 설치한 플러그인에 따라 프로젝트의 분류나 유형은 다를 수 있다. 하지만 현재는 기본적으로 설치되어 있는 코틀린 분류에 속하는 프로젝트에 관심이 있다. 왼쪽 영역에서 코틀린을 선택하면 다음과 같은 프로젝트 템플릿 목록을 볼 수 있다(그림 1.1).

>##### 그림 1.1: 새 프로젝트 마법사

버전 1.5.0(2021년 5월 기준)에서 코틀린 플러그인은 JVM, 자바스크립트, 네이티브 애플리케이션을 대상으로 하는 프로젝트 생성을 지원하며, 안드로이드와 iOS도 지원한다. 플랫폼은 사용할 컴파일러 결과물의 유형(JVM의 경우 바이트코드, 자바스크립트의 경우 .js 파일, 코틀린/네이티브의 경우 플랫폼에 따라 달라지는 실행 파일)과 프로젝트에서 사용할 수 있는 의존관계의 종류를 결정한다. 예를 들어 자바스크립트를 대상으로 하는 프로젝트에서는 자바 클래스 라이브러리에 있는 클래스에 접근할 수 없다. 이 책에서는 주로 JVM 애플리케이션에 초점을 맞춘다. 따라서 본 예제에서는 `Kotln/JVM` 옵션을 선택하고 `Next`를 클릭하라.

다음 단계(그림 1.2)에서는 프로젝트 이름과 위치를 지정한다. 프로젝트 위치는 소스파일 등 프로젝트 관련 컨텐트가 들어갈 최상위 디렉터리를 지정한다. 인텔리J가 여러분이 입력한 프로젝트 이름에 따라 자동으로 위치를 제안한다는 점에 유의하라. 하지만 원한다면 이를 변경할 수 있다.

우리가 만들 프로젝트가 JVM 플랫폼을 대상으로 하므로 프로젝트를 컴파일할 때 사용할 JDK를 지정해야 한다. 이를 통해 어떤 표준 자바 라이브러리를 사용하고 언어를 혼합해 사용하는 프로젝트라면 자바 소스코드를 어떻게 컴파일할지 지정한다. 12장, 자바 상호운용성에서 이런 프로젝트에 대해 더 자세히 다루고, 기존 자바 프로젝트에 코틀린 지원을 추가하는 방법도 다룬다.

>##### 그림 1.2: 프로젝트 이름, 위치, 의존관계

[편집자께: 자바도 16까지 나왔습니다.]

JDK8 이상을 권장한다. 이 예제에서는 www.oracle.com에서 다운로드할 수 있는 최신(2021년 5월 기준) 버전인 JDK 16을 선택했다. 보통 인텔리J가 여러분의 시스템에 설치된 JDK를 자동으로 감지하지만, 그렇지 않거나 프로젝트 SDK 목록에 적합한 JDK가 없다면 `New` 버튼을 클릭하고 JDK 최상위 디렉터리 경로를 입력해서 새로운 JDK를 추가할 수 있다. 이를 위해 JDK를 미리 설치해야 할 수도 있다. 설치를 해야 할 경우에는 https://www.oracle.com/java/technologies/javase-downloads.html 에 들어가서 설치 절차를 따라 원하는  JDK를 설치하라.

인텔리J가 프로젝트에 미리 설정해주는 코틀린 런타입 라이브러리에 대해 언급해둘만한 가치가 있다. 디폴트로 프로젝트는 IDE 플러그인 디렉터리에 있는 라이브러리를 참조한다. 이 라이브러리는 플러그인이 업데이트될 때 자동으로 업그레이드된다. 하지만 여러분의 프로젝트가 어떤 정해진 코틀린 런타임 버전에 의존하고 수동으로 필요할 때만 이 런타임을 업데이트하고 싶다면, 이 디폴트 동작을 변경할 수 있다. `Create` 버튼을 누르고 `Copy`를 선택해서 라이브러리를 보관할 디렉터리의 이름을 설정할 수 있다.

이제 마지막 단계다. `Finish` 버튼을 클릭하면 인텔리J가 빈 프로젝트를 만들어서 오픈한다. 디폴트로 인텔리J는 패널이 2가지 있는 뷰를 보여준다. 왼쪽에는 프로젝트(Project) 도구 창이 보이고, 편집기(editor)가 나머지 영역을 차지한다. 아직은 아무 파일도 연 적이 없으므로 편집기 창은 처음에는 비어있다. 따라서 처음에는 프로젝트 창에 초점을 맞추고, 이 창을 통해 새로운 코틀린 파일을 만들자.

프로젝트 도구 창이 없다면 `Project` 버튼을 클릭하거나 Alt+1(Meta+1) 단축키를 눌러서 이 창을 열 수 있다(보통은 윈도우 보더의 왼쪽 부분을 프로젝트 창이 차지한다). 

프로젝트 창은 프로젝트의 계층적은 구조를 보여준다. 루트 노드를 확장해서 안의 내용을 살펴보자(그림 1.3). 현재 흥미로운 원소는 세가지가 있다.

- `src` 디렉터리는 프로젝트에 포함된 소스 파일의 루트 역할을 한다.
- `out` 디렉터리에는 컴파일러가 생성한 바이트코드가 들어간다.
- 외부 라이브러리에는 프로젝트가 의존하는 모든 라이브러리를 포함한다.

>##### 그림 1.3: 프로젝트 구조 도구 창

이제 `src` 디렉터리를 오른쪽 클릭해서 `New | Kotlin File/Class` 명령을 선택하라. 대화창이 뜨면 파일 이름에 `main.kt`를 입려가고 `Kind` 필드를 `File`로 설정한 다음, `OK`를 클릭하라. 업로드한 프로젝트 창에 여러분이 입력한 이름의 파일이 새로 보이고, 편집창에도 같은 파일이 열린다. 코틀린 소스 파일의 확장자는 `.kt`여야 한다는 점에 유의하라.

드디어 실제로 코드를 작성할 수 있게 됐다. 편집 창에서 다음 내용을 입력하라(그림 1.4).

```
fun main() {
  println("Hello, KotlinVerse!")
} 
```

앞의 코드는 코틀린 애플리케이션의 진입점(entry-point) 역할을 하는 `main` 함수를 보여준다. 함수 본문은 명령어 한줄로 이뤄진다. 이 명령어는 인자로 받은 값을 표준 출력에 내보내주는 표준 라이브러리 함수 `println()`을 호출한다. 이 함수는 출력의 끝에 새줄 문자를 추가해준다.

>##### 그림 1.4: `Hello, World` 프로그램

자바 개발자는 분명 이 코드와 다음 자바 프로그램 사이의 유사성을 느낄 수 있을 것이다. 

```
public class Main {
  public static void main(String[] args) {
    System.out.println(“Hello, World!”)
  }
}
```

사실, 코틀린 `println()` 함수를 JVM에 맞게 컴파일한 버전은 단지 `System.out.println()`에 대한 호출일 뿐이다. JVM 진입점은 반드시 정적 클래스 메서드(static class method)여야 하기 때문에, 이런 사실을 아는 자바 개발자라면 왜 코틀린 코드가 클래스를 정의하지 않고도 실행될 수 있는지 궁금할 것이다. 답은 여기서 명시적으로 클래스를 정의하지는 않았지만, 코틀린 컴파일러가 뒤에서 자동으로 클래스를 하나 만들고 그 안에 우리가 작성한 `main()` 함수를 호출하는 진입점을 넣어주기 때문이다. 12장, 자바 상호운용성에서 파사드(facade) 클래스라고 불리는 클래스에 대해 살펴볼 것이다. 파사드 클래스는 코틀린/자바 상호 작용에서 가장 중요한 측면을 이룬다.

그리고 파라미터로 반드시 명령줄 인수를 받기 위한 배열을 지정해야 하는 JVM 진입점과 달리 코틀린 `main()` 함수는 파라미터가 없어도 된다는 점에 유의하라. 명령줄 인수가 필요없을 때 이런 점이 편리하다. 하지만 필요한 경우에는 인수를 받을 수도 있다.

```
fun main() {
  println(“Hello, KotlinVerse!”)
}
```

실제로 파라미터가 없는 `main()`은 코틀린 1.3부터 도입됐다. 1.3 버전 이전 코틀린에서는 진입점 `main` 함수에 `String<Array>` 타입의 파라미터가 반드시 있어야 했다.

`main()` 함수 정의 왼쪽에 있는 작은 녹색 삼각형을 눈치챈 독자도 있을 것이다. 이 마커는 `main()` 함수가 진입점이기 때문에 실행될 수 있다는 사실을 표시한다. 마커를 클릭하면 코드를 실행하거나 디버깅할 수 있는 메뉴가 뜬다. `Run MainKt` 옵션을 선택하고 어떤 일이 벌어지는지 보자(그림 1-5).

한편 `MainKt`는 몇 단락 앞에서 언급했던 컴파일러가 만들어낸 파사드 클래스의 이름이다. `Run` 명령을 선택하면 인텔리J는 코드를 컴파일하고 프로그램을 실행한다. 프로그램이 시작할 때 실행 도구 창이 열리고 자동으로 표준 I/O를 내장된 콘솔에 연결해준다. 모든 일이 잘 진행됐다면 프로그램이 `Hello, KotlinVerse!`를 콘솔에 출력하고 성공적으로 종료될 것이다.

>##### 그림 1.5: 프로그램 실행하기

`out` 디렉터리 안을 살펴보면 소스 프로그램으로부터 코틀린 컴파일러가 생성한 `.class` 파일들을 볼 수 있다.

축하한다! 이제 인텔리J IDEA 환경에서 프로젝트를 설정하고 실행하는 방법을 이해했고, 코틀린의 기초인 코틀린세계(KotlinVerse)를 더 깊이 파고들 준비가 됐다. 이제 간다!

## REPL 사용하기

인텔리J 코틀린 플러그인은 즉시 프로그램 실행을 평가(evaluate)할 수 있는 대화형 셀(interactive shell)을 제공한다. 이 셀을 사용해 코드를 빨리 테스트해보거나, 라이브러리 함수를 실험해볼 수 있다. 그리고 코틀린 언어를 배우는 사람들에게도 대화형 셀이 유용하다. 이런 대화형 셀을 REPL이라고 부른다. REPL은 읽기/평가/출력 루프(Read/Evaluate/Print Loop)의 약자다. 이 말은 사용자가 입력한 코드를 읽어서, 평가하고, 결과를(결과가 있다면) 출력하는 과정을 계속 반복한다는 뜻이다. REPL을 열려면 `Tool | Kotlin | Kotlin REPL`을 선택하라.

REPL 창에서는 편집기 창과 똑같이 원하는대로 코틀린 코드를 타이핑할 수 있다. 가장 큰 차이는 엔터를 누르면 입력한 코드 조각이 실행된다는 점이다. 코드를 타이핑한 후 Ctrl-Enter(Command-Return)을 누르면 입력한 내용을 IDE가 처리하게 할 수 있다. 다음을 입력하고 이 기능을 테스트해보자.

```
println(“Hello from REPL”)
```

결과를 살펴보면 인텔리J는 `Hello from REPL`를 콘솔에 출력한다. 여기서는 REPL 창이 콘솔 역할을 같이 한다.

위에 입력한 문자 출력은 실제로는 `println()` 함수의 부수 효과이며, `println` 함수 자체는 아무 값도 반환하지 않는다. 하지만 의미 있는 결과를 만들어내는 식을 평가해보면 출력이 약간 달라진다. `1+2*3`을 시도해보자(그림 1.6).

>##### 그림 1.6: REPL 사용하기

REPL은 식을 계산한 결과인 `7`을 표시한다. 조금 전의 `println` 예제의 결과와 달리 여기서는 결과 앞에 `=`이 표시됐음에 유의하라. 이 `=`는 표시된 `7`이 여러분이 입력한 코드의 실제 결과임을 나타낸다. 정리하면, 여러분이 이 도구에 익숙해지길 바란다. 앞으로 이 책에서 (그리고 여러분이 이 책을 다 읽은 후 실제 개발을 할때도) 필요한 기능을 실험할 때 REPL을 계속 사용할 수 있기 때문이다.

### 코틀린 놀이터

인텔리J에는 REPL 셀 외에도 REPL과 비슷하지만 REPL과 완전한 IDE 중간에 위치하는 더 강력한 온라인 도구가 있다. 이 도구는 코틀린 놀이터(playground)이다. 브라우저에서 https://play.kotlinlang.org 에 방문에 코틀린 놀이터를 시도해보라(그림 1.7).

코틀린 놀이터는 기본적으로 실제 IDE를 사용하지 않고도 코틀린 언어를 탐험할 수 있는 온라인 환경이다. 하지만 여전히 코드 편집기, 문법과 오류 하이라이팅, 코드 완성과 콘솔 프로그램 실행기 등 여러가지 똑똑한 기능을 제공한다. 

>##### 그림 1.7: 코틀린 놀이터

놀이터는 개발자가 주요 코틀린 기능에 익숙해지기 위한 연습문제와 예제도 제공한다. 코틀린 선문답(koans)이라고 부르는 연습문제는 성공하기 위해 코드를 수정해야 하는 실패하는 테스트 케이스 형태로 되어있다(그림 1.8).

>##### 그림 1.8: 코틀린 선문답

이런 연습문제는 이 책을 잘 보완해주는 귀중한 문제들이다. 여러분도 꼭 한번씩 풀어보기 바란다.

## 이클립스 프로젝트 설정하기

코틀린 프로그래밍 도구가 인텔리J만 있는 것은 아니다. 이클립스(Eclipse) IDE를 더 좋아하는 개발자는 이클립스 플러그인을 사용해 이클립스에서 코틀린 프로그램을 개발할 수 있다. 이클립스의 코틀린 언어 지원은 인텔리J만큼 광범위하지는 않지만, 이클립스도 개발자에게 도움이 될 수 있는 여러 코드 지원 기능을 제공한다. 예를 들어 코드 하이라이트, 코드 자동완성, 프로그램 실행과 디버깅, 기본적인 리팩토링 등을 지원한다.
이클립스가 없는 독자는 http://www.eclipse.org/downloads에서 무료로 이클립스를 다운로드할 수 있다. 설치 프로그램을 실행한 후, "Eclipse IDE for Java Developers"(또는 "Enterprise Java Developers")를 선택하고 프로그램의 지시에 따라라. 이 책에서는 2021년 나온 이클립스 2021-03버전을 사용한다.

인텔리J IDEA와 달리 이클립스는 기본적으로 코틀린을 지원하지 않는다. 이 말은 코틀린 코드를 작성하기 전에 이클립스 마켓플레이스에서 플러그인을 설치해야 한다는 뜻이다. `Help | Eclipse Marketplace...` 를 선택하고 Kotlin plugin을 검색하라(그림 1.9).

Install 버튼을 클릭하면 IDE가 플러그인을 다운로드해 설치한다. 라이선스 계약에 동의하고 이클립스를 재시작해서 설치를 마쳐라.

>##### 그림 1.9: 이클립스 마켓플레이스에서 코틀린 플러그인 설치하기

이제 프로젝트를 설정할 수 있다. 우선, `Window | Perspective | Open Perspective | Other…`를 선택하면 나오는 대화창에서 코틀린을 선택해 IDE를 코틀린 퍼스펙티브(perspective)로 바꾸자. 이 퍼스펙티브를 사용하면 코틀린 관련 액션을 애플리케이션 메뉴에서 직접 접근할 수 있다. 이제 프로젝트를 만들기 위해 `File | New | Kotlin Project…`를 선택하고, 새 프로젝트의 이름을 `KotlinVerse`로 지정한 다음에 `Finish`를 클릭하자(그림 1.10).

>##### 그림 1.10: 코틀린 프로젝트 생성하기

거의 다 됐다! 패키지 익스플로러(package explorer) 뷰에서 KotlinVerse 노드를 펼치면 새로 만든 프로젝트의 구성 요소를 볼 수 있다. 새 프로젝트에는 자바 런타임 환경(JRE) 라이브러리, 코틀린 표준 라이브러리, 소스코드가 들어갈 빈 `src` 디렉터리가 있다. 이제 첫번째 코틀린 파일을 생성하자. `src` 디렉터리에서 오른쪽 클릭을 하고 `New | Kotlin File`를 선택하라. 파일 이름을 입력한 후, `Finish`를 클릭하라(그림 1.11).

>##### 그림 1.11: 코틀린 파일 생성하기

이클립스가 자동으로 새 파일을 편집창에서 열어준다. 앞에서 예제로 사용한 "Hello, World" 프로그램을 입력하자(그림 1.12).

>##### 그림 1.12: 이클립스 "Hello, World" 프로그램

다 됐다! 프로그램을 실행하려면 `Run | Run` 명령을 사용한다. 이클립스가 여러분의 파일을 JVM 바이트코드로 컴파일하고 컴파일한 프로그램을 실행한 다음, 출력을 콘솔 뷰에 표시해줄 것이다.

## 결론

이번 장에서는 안전성, 간결성, 함수형 및 객체지향 프로그래밍 패러다임 지원 등 코틀린 언어의 여러 측면을 살펴봤다. 그리고 코틀린이 JVM, 안드로이드, 자바스크립트, 네이티브 애플리케이션 등 다양한 플랫폼을 지원한다는 점도 봤다. 자바나 다른 구체적인 플랫폼 코드 사이의 상호운용성을 위해 잘 설계된 언어이며, 광범위한 도구, 라이브러리, 프레임워크를 제공하는 생태계가 있고, 빠르게 성장중인 커뮤니티가 있어서 코틀린은 배워볼만한 훌륭한 언어이다.
그리고 코틀린 프로그래밍을 시작할 때 사용할 수 있는 인텔리J 아이디어, 이클립스 IDE, 코틀린 놀이터 등의 도구에 대해 살펴봤다. 이제 앞으로 나갈 준비가 됐다. 다음 장에서는 변수, 식 등의 기본적인 구문 구조를 샅샅히 살펴보고, 기본 코틀린 타입을 소개한다.
